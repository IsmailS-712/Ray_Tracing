{"camera":{"position":[0,0,0],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1","showWorldCoordinates":true},"passes":{"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\nin vec3 vertexNormal;\nin vec2 vertexTextureCoordinates;\n\nuniform vec3 lightPosition;\nuniform bool lightInCamspace;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nout vec2 fragmentTextureCoordinates;\nout vec3 origin;\nout vec3 dir;\n\nvoid main() {\n    float aspectRatio = canvasWidth/canvasHeight;\n    vec3 origin_camSpace, dir_camSpace;\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertexPosition.x*orthographicFOV*aspectRatio,\n                               vertexPosition.y*orthographicFOV,\n                               0);\n        dir_camSpace = vec3(0, 0, -1);\n    }\n    else { // perspective projection\n        origin_camSpace = vec3(0);\n        dir_camSpace = vec3(vertexPosition.x*aspectRatio,\n        vertexPosition.y,\n        -1.0/tan(radians(perspectiveFOV)));\n    }\n    origin = cameraPosition + cameraRotation*origin_camSpace;\n    dir = normalize(cameraRotation*dir_camSpace);\n    gl_Position = vec4(vertexPosition, 1.0);\n    fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\nuniform sampler2D textureRendered;\n\nin vec2 fragmentTextureCoordinates;\nin vec3 origin;\nin vec3 dir;\n\n#define PI 3.14159265897932384626\nconst float EPSILON = 0.001;\nconst float MAX_DIST = 1000.0;\nconst int RAY_DEPTH = 42;\n\nuniform vec3 lightPosition;\nuniform bool lightInCamspace;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\nvec4 ambient = vec4(0.1, 0.1, 0.1, 1.0);\nvec4 specular = vec4(1.0, 1.0, 1.0, 1.0);\nfloat checkerSpacing = 2.0;\nfloat falloff = 0.65;\nfloat k_a = 0.5; // Ambient Coefficient\nfloat k_d = 1.0; // Diffuse Coefficient\nfloat k_s = 0.3; // Specular Coefficient\nfloat s = 500.0;\nfloat shininess = 15.; // Specular Exponent\nfloat phi = 5000.0; // Light Intensity\n\nout vec4 fragColor;\n\nstruct Sphere {\n    vec3 centre;\n    float radius;\n    vec3 colour;\n};\n\nstruct Plane {\n    vec3 point;\n    vec3 normal;\n    vec3 colour;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Intersection {\n    float t;\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    vec3 colour;\n};\n\nSphere sphere[6];\nPlane plane;\n\nIntersection initIntersection() {\n    Intersection i;\n    i.position = vec3(0,0,0);\n    i.normal = vec3(0,0,0);\n    i.colour = vec3(0,0,0);\n    i.hit = false;\n    i.t = -1.0;\n    return i;\n}\n\nbool shadowRay(Intersection intersect);\n\nvec3 checkerPattern(vec3 pt, vec3 c) {\n    float checkerboard = floor(pt.x * checkerSpacing) + floor(pt.z * checkerSpacing);\n    checkerboard = (checkerboard * 0.5) - floor(checkerboard * 0.5);\n\n    if (mod(checkerboard, checkerSpacing) == 0.0) {\n        return c;\n    }\n    else {\n        return c * 0.5;\n    }\n}\n\nvec3 illumination(const Intersection i, const Ray ray) {\n    vec3 lightDirection = normalize(lightPosition - i.position);\n    float distance = length(lightDirection);\n    vec3 ambient_component = k_a * ambient.xyz;\n    vec3 diffuse_component = vec3(0, 0, 0);\n\n    if (!shadowRay(i)) {\n        float diffuse_val = k_d * max(dot(i.normal, lightDirection), 0.0);\n        diffuse_component = i.colour * diffuse_val;\n    }\n    vec3 reflect = reflect(lightDirection, i.normal);\n    float specular_val = k_s * pow((max(0.,dot(normalize(ray.dir), reflect))), shininess);\n    vec3 specular_component = specular.xyz * specular_val;\n    float delta_a = phi / (4.0 * PI * (distance + s)); // s is heuristic constant\n    return (ambient_component + diffuse_component + specular_component) * delta_a;\n}\n\nvec3 hitPoint(vec3 origin, vec3 direction, float t) {\n    return t * direction + origin;\n}\n\nIntersection planeIntersect(Ray ray) {\n    Intersection i = initIntersection();\n    float d = dot(ray.dir, plane.normal);\n    vec3 delta_p = ray.origin - plane.point;\n    float t = -1.0 * (dot(plane.normal, delta_p) / d);\n    \n    if (t > 0.0 && t < MAX_DIST) {\n        i.hit = true;\n        i.normal = plane.normal;\n        i.position = hitPoint(ray.origin,ray.dir, t);\n        i.t = t;\n        i.colour = checkerPattern(i.position, plane.colour);\n    }\n    return i;\n}\n\nIntersection sphereIntersect(Ray ray, Sphere s) {\n    Intersection i = initIntersection();\n    vec3 delta_p = ray.origin - s.centre;\n    float b = dot(ray.dir, delta_p); // d dot deltap    \n    float d = pow(dot(ray.dir, delta_p), 2.0) - pow(length(delta_p), 2.0) + (s.radius * s.radius);\n\n    if(d > 0.0) {\n        float t = -b - sqrt(d);\n        if (t > 0.0){\n            i.hit = true;\n            i.position = hitPoint(ray.origin, ray.dir, t);\n            i.normal = normalize(i.position - s.centre);\n            i.colour = s.colour;\n            i.t = t;\n        }\n    }\n    return i;\n}\n\nIntersection sphereReflection(Ray ray) {\n    Intersection finalIntersection = initIntersection();\n\n    for (int i = 0; i < 6; i++) {\n        Intersection currentIntersection = sphereIntersect(ray, sphere[i]);\n        if (currentIntersection.hit) {\n           if (!finalIntersection.hit || currentIntersection.t < finalIntersection.t) {\n               finalIntersection = currentIntersection;\n           }\n        }\n    }\n    return finalIntersection;\n}\n\nIntersection everyIntersection(Ray ray) {\n    Intersection sphereIntersection = sphereReflection(ray);\n    Intersection planeIntersection = planeIntersect(ray);\n\n    if (!planeIntersection.hit){\n        return sphereIntersection;\n    } \n    if (!sphereIntersection.hit) {\n        return planeIntersection;\n    }\n    if (planeIntersection.t < sphereIntersection.t) {\n        return planeIntersection;\n    }\n    return sphereIntersection;\n}\n\nbool shadowRay(Intersection intersect) {\n    vec3 direction = normalize(lightPosition - intersect.position);\n    Ray shadowRay;\n    shadowRay.origin = intersect.position + intersect.normal * EPSILON;\n    shadowRay.dir = direction;\n    Intersection shadowIntersect = everyIntersection(shadowRay);\n   \n    if (shadowIntersect.hit) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nvec3 rayTrace(Ray ray) {\n    float weight = 1.0;\n    vec3 combinedShading = vec3(0.0, 0.0, 0.0);\n\n    for (int i = 0; i < RAY_DEPTH; i++) {\n        Intersection intersection = everyIntersection(ray);\n\n        if (!intersection.hit) {\n            break;\n        }\n        combinedShading += illumination(intersection, ray) * weight;\n        weight *= falloff;\n        vec3 reflectedDirection = normalize(reflect(ray.dir, intersection.normal));\n        Ray reflectedRay;\n        reflectedRay.origin = intersection.position + intersection.normal * EPSILON;\n        reflectedRay.dir = reflectedDirection;\n        ray = reflectedRay;\n    }\n    return combinedShading;\n}\n\nvoid main() {\n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n\n    plane.point = vec3(0.0, -0.5, 0.0);\n    plane.normal = vec3(0, 1.0, 0);\n    plane.colour = vec3(1, 1, 1);\n    // scene definition end\n\n    Ray ray;\n    ray.origin = origin;\n    ray.dir = normalize((mMatrix * vec4(dir, 0.0)).xyz);\n\n    fragColor = vec4(rayTrace(ray), 1.0);\n}"}},"uniforms":{"value":{"lightPosition":{"value":[6,4,3]},"lightInCamspace":{"value":[0]},"mMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"vMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"pMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"value":[0]},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"textureRendered":{"value":{"TEXTURE_2D":""}}}}}}},"output":{"image":"Quad/R2T Pass color"}}