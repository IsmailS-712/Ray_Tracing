{"camera":{"position":[-1.7528610178874007,3.2636244627262987,39.8280834791012],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1","showWireframe":false},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex position in object space coordinates\nin vec3 vertexPosition;\n// Surface normal at the vertex in object space coordinates\nin vec3 vertexNormal;\n// Texture coordinates at that vertex\nin vec2 vertexTextureCoordinates;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\n// Main program for each vertex\nvoid main() {\n  vec4 vertexCamSpace = vMatrix * mMatrix * vec4(vertexPosition, 1.0);\n  gl_Position = pMatrix * vertexCamSpace;\n}"},"fragment":{"source":"#version 300 es\n\n// For better performance less precision\nprecision highp float;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n\nout vec4 fragColor;\n\n// Main program for each fragment = pixel candidate\nvoid main() {\n  fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}"}},"uniforms":{"value":{"lightPosition":{"value":[0,0,0,1]},"lightInCamspace":{"value":[true]},"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\nin vec4 vertex_worldSpace; \n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\n\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\n\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nout vec3 origin;  \nout vec3 dir;   \n\n\nvoid main() {\n    \n    float aspectRatio = canvasWidth/canvasHeight; \n\n    vec3 origin_camSpace, dir_camSpace;\n\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n                                vertex_worldSpace.y*orthographicFOV,\n                                0) * vec3(vMatrix) * vec3(mMatrix); \n        dir_camSpace = vec3(0, 0, -1);\n    }\n    else { \n        origin_camSpace = vec3(-0.5, 0.0, -2.0) + vec3(vMatrix) * vec3(mMatrix) * vec3(pMatrix) ;\n        dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n                            vertex_worldSpace.y, \n                            -1.0/tan(radians(perspectiveFOV)));\n    }\n    origin = vec3(-0.5, 0.0, -2.0)+ cameraPosition + cameraRotation*origin_camSpace;  \n    dir = normalize(cameraRotation*dir_camSpace);               \n\n    gl_Position = vertex_worldSpace;\n}\n"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\nuniform vec3 lightSource;       \nuniform float shininess;\nuniform vec3 ambientColour;\nconst float phi_s = 1000.0;\nconst float PI = 3.1415926535897932384626433832795;\n\nlayout(location = 0) out vec3 origin;  \nlayout(location = 1) out vec3 dir;\nlayout(location = 2) out vec4 fragColor;\n\nconst int maxTraceDepth = 42;   \nconst float epsilon = 0.00001;\nfloat k_ref = 0.5;\n\nstruct Sphere\n{\n  vec3 centre;\n  float radius;\n  vec3 colour;\n};\n\nstruct Plane\n{\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n}plane;\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n};\n\nstruct Intersection\n{\n  float hit;    \n  float mu;\n  vec3 hitPoint;\n  vec3 normal;    \n  vec3 colour;    \n  vec3 diffuseColour;\n  vec3 specularColour;\n};\n\nvec3 shadowTracing(Intersection intersect, Sphere sphere[6], Plane p);\nvec3 diffuseIllumination(Intersection i, Ray ray);\nvec3 specularIllumination(Intersection i, Ray ray);\nIntersection intersectSphere(Ray ray, Sphere sphere[6], Intersection i_s[6]);\nIntersection intersectPlane(Ray ray, Plane p, Intersection i_p);\nIntersection intersectObject(Ray ray, Sphere sphere[6], Plane p);\n\n\nvec3 shadowTracing(Intersection intersect, Sphere sphere[6], Plane p){\n    Ray shadowRay;\n    shadowRay.origin = intersect.hitPoint + epsilon * intersect.normal;  \n    shadowRay.dir = normalize(lightSource - intersect.hitPoint);\n\n    vec3 colour;\n\n    Intersection shadowRay_i = intersectObject(shadowRay, sphere, p);\n    if (shadowRay_i.hit == 0.0){  \n        colour = ambientColour * intersect.colour + intersect.specularColour + intersect.colour * intersect.diffuseColour;\n    }\n    else{      \n        colour = ambientColour;     \n    }\n    return colour;\n}\n\n\nvec3 diffuseIllumination(Intersection i, Ray ray){\n    vec3 n = i.normal;\n\n    vec3 l = normalize(lightSource - i.hitPoint);\n    vec3 r = normalize(2.0*dot(n, l)*n-l);\n    vec3 v = normalize(ray.origin - i.hitPoint);\n\n    float d = length(lightSource - i.hitPoint);\n    float attenuation = 1.0/(4.0*PI*d*d); \n    \n    vec3 diffuseColour = i.colour*max(dot(n, l), 0.0)*phi_s*attenuation;  // diffuse reflection (max to prevent negative)\n\n    return diffuseColour;\n}\n\n\nvec3 specularIllumination(Intersection i, Ray ray){\n    vec3 n = i.normal;\n\n    vec3 l = normalize(lightSource - i.hitPoint);\n    vec3 r = normalize(2.0*dot(n, l)*n-l);\n    vec3 v = normalize(ray.origin - i.hitPoint);\n\n    float d = length(lightSource - i.hitPoint);\n    float attenuation = 1.0/(4.0*PI*d*d); \n    \n    vec3 specularColour = i.colour*pow(max(dot(v, r), 0.0), shininess)*phi_s*attenuation; // specular reflection\n\n    return specularColour;\n}\n\n\nIntersection intersectSphere(Ray ray, Sphere sphere[6], Intersection i_s[6]){\n    for (int i=0; i<6; i++){\n        vec3 delta_p = ray.origin - sphere[i].centre;    \n        float c = (length(delta_p) * length(delta_p)) - (sphere[i].radius * sphere[i].radius);\n        float b = dot(ray.dir, delta_p);\n        float d = b * b - c;    \n        float mu1 = - b - sqrt(d);  \n        float mu2 = - b + sqrt(d);\n\n        if (d > 0.0){   \n\n            if (mu1 > 0.0 && mu2 > 0.0){    \n                i_s[i].hit = 1.0;\n                i_s[i].mu = min(mu1, mu2);  \n                i_s[i].hitPoint = ray.origin + i_s[i].mu * ray.dir;\n                i_s[i].normal = normalize(i_s[i].hitPoint - sphere[i].centre);   \n                i_s[i].colour = sphere[i].colour;  \n                i_s[i].diffuseColour = diffuseIllumination(i_s[i], ray);  \n                i_s[i].specularColour = specularIllumination(i_s[i], ray); \n            }\n            else{\n                i_s[i].hit = 0.0;\n            }\n        }      \n        else{\n            i_s[i].hit = 0.0;\n        }\n    }\n\n    float closest_s_mu;\n    Intersection closest_intersect;\n\n    for (int i=0; i<6; i++){\n        if (i_s[i].hit == 1.0){\n            closest_s_mu = i_s[i].mu;   \n        }\n    }\n    for (int i=0; i<6; i++){  \n        if (i_s[i].hit == 1.0 && i_s[i].mu < closest_s_mu){\n            closest_s_mu = i_s[i].mu;  \n        }\n    }\n\n    for (int i=0; i<6; i++){\n        if (i_s[i].hit == 1.0 && i_s[i].mu==closest_s_mu){\n            closest_intersect = i_s[i];\n        }\n    }\n    return closest_intersect;\n}\n\n\nIntersection intersectPlane(Ray ray, Plane p, Intersection i_p){\n    vec3 delta_p = ray.origin - p.point;\n    float pn = dot(delta_p, p.normal);\n    float dn = dot(ray.dir, p.normal);\n    float mu = - pn/dn;\n\n    if (mu >= 0.0){  \n        i_p.hit = 1.0;\n        i_p.mu = mu;\n        i_p.hitPoint = ray.origin + mu * ray.dir;\n        i_p.normal = p.normal;\n\n        \n        float grid_x = floor(i_p.hitPoint.x*1.5);\n        float grid_z = floor(i_p.hitPoint.z*1.5);\n        if (mod((grid_x + grid_z), 2.0) == 0.0){\n            i_p.colour = vec3(0.0,0.0,0.0);  \n        }\n        else{\n            i_p.colour = p.colour;   \n        }\n        i_p.diffuseColour = diffuseIllumination(i_p, ray);  \n        i_p.specularColour = specularIllumination(i_p, ray); \n    }\n    else{\n        i_p.hit = 0.0;\n    }\n    return i_p;\n}\n\n\nIntersection intersectObject(Ray ray, Sphere sphere[6], Plane p){\n    Intersection i_s[6];    \n    Intersection i_p;      \n    \n    Intersection closest_s_i = intersectSphere(ray, sphere , i_s); \n\tIntersection closest_p_i = intersectPlane(ray, p, i_p);  \n\n    Intersection closest_i;     \n\n    if (closest_s_i.hit == 1.0 && closest_p_i.hit == 1.0){  \n        if (closest_s_i.mu < closest_p_i.mu){  \n            closest_i = closest_s_i;\n        }\n        else{\n            closest_i = closest_p_i;\n        }\n    }\n    else if(closest_s_i.hit == 1.0 && closest_p_i.hit == 0.0){ \n        closest_i = closest_s_i;\n    }\n    else if(closest_s_i.hit == 0.0 && closest_p_i.hit == 1.0){  \n        closest_i = closest_p_i;\n    }\n\n    return closest_i;\n}\n\n\nvoid main() {\n\n    Sphere sphere[6];\n\n    sphere[0].centre = vec3(-2.0, 1.5, -3.5); \n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8); \n\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0); \n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3); \n\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8); \n\n    sphere[3].centre = vec3(0.7, -0.3, -1.2); \n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3); \n\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2); \n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3); \n\n    sphere[5].centre = vec3(0.2, -0.2, -1.2); \n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8); \n\n    plane.point = vec3(0,-0.5, 0); \n    plane.normal = vec3(0, 1.0, 0); \n    plane.colour = vec3(1, 1, 1);\n\n\n    Ray ray;\n    ray.origin = origin;  \n    ray.dir = normalize(dir);   \n\n    vec3 outputColour = vec3(0.0, 0.0, 0.0); \n\n    Intersection intersect;     \n    intersect.hit = 0.0;       \n    intersect.colour = vec3(0.0, 0.0, 0.0);\n\n    for (int depth=0; depth < maxTraceDepth; depth++){ \n        intersect = intersectObject(ray, sphere, plane);\n        \n        if (intersect.hit > 0.0){  \n            \n            intersect.colour = shadowTracing(intersect, sphere, plane);  \n            outputColour += intersect.colour * pow(k_ref, float(depth));\n        }\n        else {\n            break;\n        };\n        ray.origin = intersect.hitPoint + epsilon * intersect.normal; \n        ray.dir = normalize(reflect(ray.dir, normalize(intersect.normal))); \n    }\n\n    fragColor = vec4(outputColour, 1.0);\n}\n\n\n"}},"uniforms":{"value":{"mMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"vMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"pMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"canvasWidth":{"value":[0]},"canvasHeight":{"value":[0]},"cameraPosition":{"value":[0,0,0]},"cameraRotation":{"value":[1,0,0,0,1,0,0,0,1]},"isOrthographicProjection":{"value":[0]},"orthographicFOV":{"value":[0]},"perspectiveFOV":{"value":[0]},"lightSource":{"value":[0,0,0]},"shininess":{"value":[0]},"ambientColour":{"value":[0,0,0]}}}}}},"output":{"image":"Quad/R2T Pass color"}}